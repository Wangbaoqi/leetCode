---
sidebar_position: 42
---

# 合并 K 个升序链表

import CodeBlock from '@theme/CodeBlock';
import TestCode from '!!raw-loader!./problem.test';
import SourceCode from '!!raw-loader!./index.ts';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeSandpack from '@site/src/components/CodeSandpack';

[leetCode](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

:::info

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

:::

示例 1:

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

示例 2:

```
输入：lists = []
输出：[]
```

从题意可联想出，可以使用合并两个有序链表来解决

**1. 循环遍历合并相邻链表**
可以遍历链表，将已经合并的链表作为新链表和下一个链表进行合并
不过这种方法的时间复杂度比较长 `O(K^2 * n)` 其中`K`为数组的长度，`n`为链表的长度，而时间复杂度为`O(1)`

**2. 分治法合并相邻链表**

可以将链表数组根据二分法拆分成单个链表，从而一次合并两个有序链表
时间复杂度 O(kn×logk),空间复杂度 O(logk)

<CodeSandpack
	id={'20'}
	activePath='/index.ts'
	visibleFiles={['/index.ts', '/problem.test.ts']}
	files={{
		'/index.ts': SourceCode,
		'/problem.test.ts': TestCode
	}}
/>
